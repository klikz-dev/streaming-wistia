'use strict';

var _ = require('lodash');
var base64 = require('base64url');
var sha1 = require('sha1');
var errors = require('./errors');
var sequelize;
var config,
	route,
	secret = 'gundam',
	delimiter = '&&';
var utils = function() {};

/**
 * @private
 * Initializes the utils module
 * @param {Object} options - the config
 * @param {Sequelize} - the sequelize instance
 * @param {Object} - the route info (request, response, next)
 * @returns {Function} with various utility functions
 */
module.exports = function(options, seq, rt) {
	config = options;
	sequelize = seq;
	route = rt;
	return utils;
};

/**
 * @private
 * A wrapper that converts bluebird promises into the standard ES6 promises
 * @param {Bluebird.Promise} promise - a bluebird promise
 * @returns {Promise} that conforms to the ES6 promise standards
 */
var promisify = utils.promisify = function(promise) {
	return new Promise(function(resolve, reject) {
		promise.then(resolve).catch(reject);
	})
};

/**
 * @private
 * Returns the appropriate user query depending on the sameSocialEmails setting.
 * This determines whether to just check accounts of a specific type or all of them
 * @param {String} email - the email to search for
 * @param {String} type - the account type
 * @returns {Object} that represents what to query
 */
utils.userQuery = function(email, type) {
	return config.sameSocialEmails ? { email: email, type: type } : { email: email };
};

/**
 * @private
 * Returns the number of session a given user currently has
 * @param {String} userId - the id of the user to search
 * @returns {Number} of sessions
 */
utils.getNumSessions = function(userId) {
	return promisify(sequelize.query("SELECT * FROM sessions WHERE sess -> 'user' ->> 'id' = '::id'", {
		replacements: { id: userId },
		type: sequelize.QueryTypes.SELECT
	}))
	.then(function(sessions, metadata) {
    	return sessions.length;
  	});
};

/**
 * @private
 * Determines if the given string is a valid password given the regex defined in the config
 * @param {String} password - the string to check
 * @returns {Boolean} of whether it's valid or not
 */
utils.validPassword = function(password) {
	return config.passwordRegex ? config.passwordRegex.test(password) : true;
};

/**
 * @private
 * This ensures changes are captured while any values that are undefined aren't included, without having to call delete on the original object
 * @param {Sequelize.Instance} user - a sequelize instance of a user
 * @param {Object} obj - an object containing the updates to make to the metadata object
 * @returns {Object} of what the updated metadata should be (excluding the fields that were removed)
 */
utils.getMetadataUpdates = function(user, obj) {
	var unset = _.keys(obj).filter(function(key) {
		return obj[key] === undefined;
	});
	return _.omit(_.merge(user.get('metadata'), obj), unset);
};

/**
 * @private
 * Creates a encoded slug that encapsulates a user id and a date
 * @param {Sequlize.Instance} user - a sequelize instance of a user
 * @param {Date} date - a date object to also encode
 * @returns {String} encoded in base 64
 */
utils.createSlug = function(user, date) {
	var slugText = user.get('id')+delimiter+date.toISOString()+delimiter+sha1(secret);
	return base64.encode(slugText.split('').reverse().join(''));
};

/**
 * @private
 * Decodes slugs generated by createUserSlug()
 * @param {String} slug - the slug
 * @returns {Object} containing the user id and the date
 */
utils.decodeUserSlug = function(slug) {
	try {
		var decodedSlug = base64.decode(slug).split('').reverse().join('').split(delimiter);

		if(decodedSlug[2] !== sha1(secret))
			return errors.newError('InvalidSlugError');

		var decoded = { userId: decodedSlug[0], expiration: new Date(decodedSlug[1]) };
		return decoded;
	} catch(err) {
		return errors.newError('InvalidSlugError');
	}
};

